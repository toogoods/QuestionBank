## 题目列表

### JavaScript

#### 数组的方法有哪些
map foreach reduce join pop push unshift shift slice splice filter reverse

map 数组循环，回调函数中return的返回值会拼接成新数组返回，不可以修改基础数据类型的值，可以修改对象数据类型的属性

foreach 数组循环，不返回值，可以修改基础数据类型的值

reduce 累计上一次运行的结果，在下一次中作为参数1使用

join 通过参数将数组拼接为字符串，空参默认为,(逗号)

pop 将数组最后一个元素作为返回值取出，并删除最后一个元素（改变原数组）

push 将参数添加到数组尾部

unshift 将数组第一个元素作为返回值取出，并删除第一个元素（改变原数组）

shift 将参数添加到数组头部

slice [start, end) (数学符号，方括号表示包含，圆括号表示排除) 取start到end之间的数据，返回为原数组的浅拷贝(对象数组中的属性会同步修改)，end默认为数组尾部

splice (index, length, [...replaceItem]) 在索引index位置替换或删除length个数据，替换的值为replaceItem，参数可无限添加

filter 在回调方法中通过return true返回的元素组成新的数组（原数组的浅拷贝，对象数组中的属性会同步修改）

reverse 将数组倒序处理，返回原数组的引用，并修改原数组

#### 对象数组在map中遍历，能否修改对象中的属性值？
可以修改，因为遍历得到的是数组中每一项对象的浅拷贝，数组中存储的值是每一项对象的内存空间地址，由于对象数据本身存储在堆内存空间，其中的属性并不直接存储在数组中


#### JS内存中栈和堆的区别，存储的数据类型是什么
栈空间的存储方式为数据结构的栈，内存空间小，查询速度快（基于栈的特点）
堆空间的存储方式为数据结构中的二叉树，基于优先级原则存储，内存空间大，查询速度慢（基于堆的特点，需要），空间可扩展性高

栈中存储基础数据类型的数据（string/boolean/number等），堆存储引用类型数据(对象/数组/函数等)



#### 深拷贝 浅拷贝

#### 闭包
内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来

使用闭包会包含其他函数的作用域，会比其他函数占据更多的内存空间，不会在调用结束之后被垃圾回收机制（简称GC机制）回收，多度使用闭包会过度占用内存，造成内存泄漏

#### 原型链
构造函数创建一个实例的过程
1. 创建一个新对象
2. 将构造函数的作用域赋值给新对象（这样this就指向了新对象）
3. 执行构造函数中的代码（为新对象添加实例属性和实例方法）
4. 返回新对象

prototype属性指向函数的原型对象
原型对象中constructor指向该函数
这样原型对象和它的函数之间就产生了联系

每个通过构造函数创建出来的实例对象都存在__proto__属性，指向实例对象的构造函数的原型对象
可以通过 Object.getPrototypeOf 方法获取原型对象

#### 作用域链

#### 防抖、节流

#### 宏任务、微任务
javascript从诞生之日起就是一门 单线程 的 非阻塞 的脚本语言
宏任务: setTimeout/setInterval/Ajax
微任务: promise.then/await、async

### css
高度塌陷，flex布局，垂直居中 盒子模型 动画效果

### 算法

### webpack打包
#### webpack的构建流程
1. 初始化参数
从配置文件和shell语句中读取和合并参数，得到最终的参数
2. 开始编译
使用第一步得到的参数，初始化Compiler对象，加载所有配置的插件，执行compiler对象的run方法开始执行编译
3. 确定入口
根据配置中的entry找出所有的入口文件
4. 编译模块
从入口文件出发，调用所有配置的Loader对模块进行编译，找出该模块依赖的模块，再递归本步骤直到所有依赖文件都经过本步骤的处理
5. 完成编译模块
在经过第4步使用Loader编译完所有模块之后，得到每个模块被编译后的最终内容以及它们之间的依赖关系
6. 输出资源
根据入口和模块之间的关系，组装成一个个包含多个模块的chunk，再把每个chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
7. 输出完成
在确定输入内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

#### webpack热更新原理
缩写为HMR(Hot Module Replacement)，功能是做到不用刷新浏览器而将新变更的模块替换掉旧的模块

HMR的核心就是客户端从服务端拉取更新后的文件，准确的说是chunk diff（chunk需要更新的部分）, 实际上webpack-dev-server与浏览器之间维护了一个WebSocket， 当本地资源发生变化时，webpack-dev-server会向

### 问题查找方案、能力
